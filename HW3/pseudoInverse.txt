VectorNd_t angularVector(coef_mat.cols());

MatrixN_t JacobianInverse(coef_mat.cols(), coef_mat.rows());

//JacobianInverse = (coef_mat.transpose()*coef_mat).inverse()*coef_mat.transpose();

JacobiSVD<MatrixN_t> svd(coef_mat, ComputeThinU | ComputeThinV);

MatrixXd sigma(3,3);

for (int i = 0; i < 3; i++)
{
    for (int j = 0; j < 3; j++)
    {
        if (i == j)
        {
            sigma(i, j) = svd.singularValues()[i];
        }
        else
        {
            sigma(i, j) = 0;
        }
    }
}

JacobianInverse = svd.matrixV()*sigma.inverse();
JacobianInverse = JacobianInverse*svd.matrixU().transpose();
angularVector = JacobianInverse*desired_vector;

//return math::VectorNd_t();
return angularVector;